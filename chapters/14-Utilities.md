# 实用工具

每个Unix机器上都安装着数目繁多的程序，不管是系统原生的还是厂商附加的。这其中包括编辑器，格式器，编译器。实用工具使得用户有一个字母列表跟踪程序或者文档的不同版本，去“伸手戳一下”其他用户。这章将用来讲述它们中的一部分:非常早期的——**troff**，**eqn**，**tbl**，**yacc**，**mail**，**make**，**awk**，还有最近出现的——UUCP，TCP/IP。最后两个又引发了其他的实用工具(Mike Muuss的ping和Earl Cohen的finger就是很好的例子)，并且几乎立即就出现了一个世界范围的由各种不同用户组成的社区。这个社区对Unix来时及其重要。各种问题，解决方案，程序，抱怨，宣告等等都在社区里自由的交换传送。整个社区建立在大约3000万到3500万的网络用户之上——就像John Quarterman所说的，比加拿大的总人口都要多。

mail和roff以及ed一样，在Unix第一版时就存在了。Morris曾经将roff移植到635上，McIlroy用BCPL语言将它重写。Thompson将它移植到了Unix。但Joe Ossanna不久又将roff合并到了troff，一个真正针对电传打字机文档的格式器。Ossanna死于1977年11月28，McIlroy告诉我:

> Joe是军需官，他游走于各个厂商，打探硬件的最新发展，和设备部门做交易，还做了很多很多其他的事。他是一个严厉而有吸引力的人。

eqn在第5版的时候加入进来。Brian Kernighan说这是他对Unix做出的第一个重大贡献。就像他向Collinson说的:

> 那个时候所有的程序都是用汇编语言写成的。troff的最早版本应该是在1972年晚期或者1973年写的，它是一个汇编语言程序并且只针对特定的图形排字机系统。在今天仍然有许多事情依然受到troff语言那古老机器语法的影响。

> Joe Ossanna将它转换成C语言，我认为他受到了相当大的影响，他并不真的想将它转为C语言。他死于1977年，之后我接手了它的工作，事实上，虽然我花费了至少一年半的时间试着去编译它。我开始让它独立于图形排版系因为那时它的优势已经很明显了。我开始投入到图形中因为新型的默根瑟勒排版机可以做一些受限的图形操作，你可以非常精细的定位，你可以画直线和曲线。

> Mike Lesk大概在1975年做了**tbl**，在Lorinda Cherry和我做出**eqn**不久之后(Cherry告诉我他开始着手项目的时候Kernighan就加入了，但Kernighan因为非常成功的语法而出名)。**eqn**是第一个文档预处理器。它是我们强行实现的一个好主意，需求是发明之母。**troff**几乎用尽了PDP-11/40s的所有地址空间，它用汇编语言写成。我从来没有学过PDP-11s的汇编，我想Honeywell是最后一个我知道汇编语言的机器。

> Joe独自保持维护**troff**，他对于修改它使它工作有着难以置信的兴趣。但这是他的程序，他不想让其他人参加进来。这些事情加起来意味着Lorinda和我不得不去做一个分割程序。

> 几个事情合作的非常好。C语言变得非常具有可用性，yacc分析生成器刚刚出现，管道也刚被发明出来。所有这些事情一起使商用变得可能。

Kernighan和Cherry实现的“一个数学排版系统”发表在1975年3月的CACM上。1976年9月14日，M.E.Lesk实现的的“Tbl——一个格式化表格”发表在贝尔实验室计算机科学技术报告第49期上。和troff一起，这些预处理程序使得Unix用户可以排版各种各样的复杂文档。精心制作的宏包，增强了的**-mm**(memorandum)宏极大地扩展了功能。Mike Lesk写了**-ms**宏，Eric Allman写了**-me**宏。只有**-ms**出现在Unix的研究版本，**-mm**出现在第三第四版本。**-me**和**-ms**出现在BSD(Lesk还写了**refer**，可以使用引用数据库提供引用和脚注)。

yacc(yet another compiler-compiler，有一个编译器的编译器)，是Steve Johnson的作品。他在Unix出现之前很久就已经在贝尔实验室工作了:

> 我在1963年有了第一份工作。我总是对计算机感兴趣，当我拿到学士学位，我试着找一个研究生学校。只有很少的地方我可以去，这些地方大部分都属于电力工程部门，在那里我不得不学习发电站的建设以及其他那些我完全不感兴趣的课程，所以我决定去学数学。因此我在63年夏天去了贝尔实验室，Tom Growley是我的第一个老板...那里有一个基本的规矩，你不能连续两个夏天都在同一个组工作。因此下一个夏天我去了ALPAC的数学组。再之后的那个夏天，我依照流程去了人类信息处理组，那里有声音，语言，心理方面的人们设计实验和进行数据分析。他们需要做一些多维度的工作，这使得聚类成为我的第一篇论文，它在我所有的出版物种有着最多的引用——一共有700之多。

> 当我完成我的论文，我去贝尔实验室。我可以选择我将要去到哪个组，最后我选了人类信息处理组，因为他们会用一些我很感兴趣的计算机音乐。我在那里做了很多事情。也在那个时候，Multics被认为是繁重计算工作的解决方案，但它是一场灾难。基本上，我们购买了7094并把它运送到印第安山实验室，并且除了645上的GECOS没有其他系统可用。GECOS可以支持1000个用户但是1个就会很勉强(McIlroy向我指出645“运行了大量的批处理”)。

> 因此，到了下一年，在极端努力之下这台几百万美元的机器可以运行FORTRAN程序了，我同意帮助他们的工作去介绍分时系统。因此在1969年我实际上在Comp中心和一个小组一起工作。在这些时间里，Comp中心分化出了计算机科学研究实验室。然后有了办事员，计算机操作员，打卡员等等这些向研究部门汇报的员工。我到那里一年之后，他们才姗姗来迟地设立了一个组织运营计算机中心。我决定宁愿留在研究中心，那样有个后门我可以去做Unix的组。

> 我最早是和Dennis Ritchie一起工作于另一个叫做Altran的计算机代数系统。Dennis写了Altran语言的编译器。它是一个用FORTRAN写的递归下降编译器，这绝对是一件杰作，就像用牙签建造了一幢摩天大楼。他曾经为B语言写过一个运行在Honeywell系统上的编译器，我们用它写一些系统程序。但当他和Ken开始为Unix工作时，他终止了他的B语言编译器，然后我领取了它。这个语言里面有一些我想要的东西，比如我添加了高级OR操作符。我从和Dennis一起工作中学到了很多编译器的知识，并且这是一个非常体面的工作。我变得相信你可以通过阅读其他人的代码学到非常多的东西。阅读那些杰出的名著。

> 当我想添加这个的时候，我向Al Aho请教，因为我听说他对处理表达式的新方法很有兴趣。这是一种非常有趣的情景。Al不停的点头说:“是的，我读了Knuth的这篇论文，这是一个非常好的方法”。所以我们用B语言做出一个非常简单的表达式语法，并且他还不断地说“我会给你做出解析表来”。但是它最后还是延期了一些时间。最后，他去仓库找到他们最大的一张纸，足有两平方英尺那么大。他把它平铺在桌子上，裁成小的方形纸，然后他边小声念叨着咒语一样的东西边在上面写下一些小符号。我看着他做了一会，他说:“你为什么不去做些其他的事情？我做完了会给你说的”。我就走开了，没过几个小时回来看时他仍然在念叨着咒语在纸上写写画画。在傍晚的时候他终于说:“我明天把它做完”。最后到了第二天，他说:“完成了！”，然后把它递给我。我说:“我能拿这个做什么？”。

> 他就向我展示怎么做一个解析器，我们一起将表格输入计算机。然后我们就试着解析一些表达式，结果完全正确。接着我们又解析了另一些，但是却出错了，表格里面有一些bug。Al说:“喔，天哪”，然后又花费2，3个小时擦除重写，最后我们把新的表格输入进去，终于解决了那个bug，但是却出现了另一个bug。于是我说:“Al，为什么你不告诉我你在做什么？”。他说:“好吧，这实际上并不难”，然后他交给我怎么制作表格。然后我说:“奥，我可以写个程序来做这个”，“真的？”。于是就诞生了**yacc**。

Johnson同时也和Dennis Ritchie一起在向Interdata 8/32上移植的时候写了第一个可移植的C编译器，lint，spell。lint是一个C程序检测器，可以检测C代码文件是否有bug或者可移植之类的问题。spell是一个拼写检查器，它从文件搜集单词然后在一个拼写列表里面查找它们，单词既没有出现，也不能从拼写列表推导出来，就把它从标准输出打印出来。spell不是第一个拼写检查器，第一个拼写错误检查程是Bob Morris和Lorinda Cherry的typo。它包含在第三版到第七版。spell第一次出现在第五版。typo，用Steve Johnson的话说:

> 从来没有检查出我的拼写错误。我非常偏重通过发音拼写，经常弄混ible和able，以及ance和ence，但是typo从来没有发现这些。它是基于三角统计，我的错误全都出现了。但是typo非常擅长找出缺少e的th。它会将单词按最不可能出现的顺序排序。

Johnson的拼写检查器实际上引用了一个用户可以自行扩展的单词列表。他告诉我:

> 我在1973年的1月到9月去滑铁卢大学学术休假，和Morven Gentleman(现在在加拿大的国家科研委员会)一起做一些工作。Morven曾经在原始的ALPAC系统上工作过，他对计算机代数非常感兴趣。我们一起做成了一些工作，他是一个非常有趣的人。事实证明那时不是一个合适的时间。当我去那里时C语言刚被发明出来，当我离开时，yacc被一些人从B语言翻译到了C语言。同时MIT的合作学生Alan Snyder也开发了第一个可移植的C译言编译器。那是一个非常具有颠覆性的尝试，包含了很多非常好的点子在里面。但因为PDP-11内存太小的原因，它是一个四阶编译器。并且它还非常昂贵——每一阶段都将大部分时间花费在读取上一阶段的结果和为下一阶段输出结果，真正做事情的时间反而非常之少。

> 因此它非常的慢，就算老式的B语言编译器也要比它快很多。Al努力让它可以在Honeywell工作，但是仍然有许多的bug。正好，在我从加拿大返回的时候，他也回了MIT，因此我接手了这个项目。我的老板Elliott Pinson强烈建议我我应该接管它。我试着修正代码生成器里面的bug，发现很大部分都是Al做东西的风格。你知道，那时候的代码生成器使用一种我称之为“woopsie”的方式:你确信你有所有需要的寄存器，并且所有的东西都会在正确的位置，当有错误出现时就会发出“woopsie”，然后去找一些东西加载到内存里。大多数时候这都会是一个好的代码，但是当它出了错时那是相当可怕的...

> 好吧，我去向Al Aho解释这些，这些谈话导致了我认为我在理论方面最好的技术工作——一个为表达式生成代码的算法，它输出可选择的代码...Al和我，还有Jeff Ullman也做了一些，我们一起做了相当有趣的工作。对我来说最终的结果就是我更好的理解了代码生成。

> 后来，我们为PDP-11争取到了更多的内存，这使得我可以将一些Al Snyder的程序放在一起运行。不久之后我重写了所有的软件，保留了一点Al的语法，但是没有任何他的代码留存下来。我将这个可移植的C编译器叫做pcc。我原本是打算做Honeywell的编译器，但后来我们认为将它移植到IBM会非常美好。于是我将Honeywell版本做了一些hack，就成了360版本。再之后有一个叫做3A的交换机，我为他做了一个编译器。在这些过程中我意识到我为这三台机器做了相当多的重复工作，因此我开始认真检查，将这三个编译器放在一起发现它们90%的代码是相同的。于是，我在脑海里为其他的10%建立了一个程序...

> lint是一个有趣的故事。当我决定我真的要去写一个可移植编译器，将这三个编译器打造成一个真正可移植的版本，我知道怎样去做前端，但是对于代码生成我依然不太了解...所以我需要将前端代码全部检测，但是却没办法去检测。我想或许我可以在前端做一些有用的事情，如果它真的有用，人们将会用它检测自己的代码，也就是帮我测试了。然后，怎么样才是有用的呢？前端是支持解析函数的...我说好吧，一个经常出现的编程错误就是使用了错误的参数个数调用函数。实际上，指出是哪个函数并不是很容易办到。于是我写了一个程序，它可以读取你的代码文件，最初它会告诉你是哪个函数出错了。然后我意识到它可以在函数调用间也做测试。因此lint真的成为我调试编译器前端代码的一个工具。一言以蔽之，它在各种组织中扮演公共品行守卫者的角色。

> 你知道，当1977年我们第一次移植Unix的的时候，我们有一个非常严重的问题，我们有许多代码是人们看着手册写的，他们直接复制了手册上的数据结构声明。当我们介绍头文件的时候，我们设想了机器之间的不同。我们想确认Unix程序都是使用了头文件，特别是操作系统使用的那些头文件。因此lint学着去做的第一件事就是检查头文件的一致性...这让我们可以检查大量的代码——第六版的Unix只用了短短几个星期就解决了一致性问题。它帮助我们将它们合并到第七版的使用工具(第七版是第一个可移植系统)。

克制住想谈论Unix没一件事情的冲动，在转移到通信前我们先专注于**awk**。Peter Collinson向Brian Kernighan请教关于**awk**的事情:

> 我想**awk**是从1977年开始出现的，到目前为止它是我参与过的最大的软件项目。我们中有三个人参与进来，但却完全没法工作。不知为什么，两个人在一起工作要远比三个人容易。工作分割非常困难。大家在想法上有很多分歧，这有时是好的因为意味着更多的创意，但是有时却意味着大家并不团结。换句话说和Al Aho以及Peter Weinberger一起工作非常非常的棒，所以我并没有那些问题。

> 一共有三个单独的进度在同时进行。我的那部分是那时还在实验室的Mark Rochkind做的一个工具。这是一个非常基础的数据验证工具，它使用成对的正则表达式和消息，通过扫描输入文件查找是否有符合给出的正则表达式，如果有的话我就会打印出消息。当然，他是用C语言写的这个识别器。这是一个非常优雅的主意。

> 某种程度上说，那时**awk**的基本概念。有一大堆的模式，还有许多互相依赖的东西要完成。它不像已有的那些程序，它是他们中非常清晰的一个。我也在可编程编辑器方面混了很长一段时间，我们经历了**qed**非常流行的阶段。**qed**是一个非常糟糕的编程语言，但人们偏偏都在用它。

> 有一个行编辑器拥有与多个buffer和多个文件，非常像今天的**emacs**。

> 我不停思考一定有更好的方式去操作文本。有些事情会像我想要的那样允许你清晰的同时操作文本和数字。

> Al Aho在正则表达式方面是世界级的专家。Peter Weinberger在数据库相关的方面有着非常强的背景，并且对数据库之类的东西非常感兴趣。现在，**awk**绝对不是一个数据库，但是它有这方面的趋势，这来自Peter的数据库经验。因此，我们将这些混杂主意糅合到一起想做出一个东西。

> 它最初的想法是写一两行代码，真的是这样。我想它是非常迷人的因为它自动做了这么多事情。它流畅的处理字符串和数字。它是一个解释器并且没有包袱，没有中间文件。人们开始试着写一两行代码，然后代码越来越多，有一些大的难以置信，据说有人曾写出一万行的代码。

> **awk**总是在慢慢变化。有一点可以追溯到我的那个想法，我真的希望有一个编程语言可以让我写程序操作文本就像操作数字一样方便。我想相比于B语言发展到C语言，我会去寻找另外一个方向。

> 我发明了一种我称之为A的语言，使用了awk的基本概念并且用编程语言将它们包装起来。它工作的并不太好。它有一些功能可以展示，但是它没有使用任何隐式的输入输出或其他类似的东西。我使用了它但是它始终都不够好。它的实现方式真的非常古怪，因此 我一直没怎么用它，也没有其他人用过它。

> 
