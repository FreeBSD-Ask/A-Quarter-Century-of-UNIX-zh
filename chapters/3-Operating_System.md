# 操作系统

普度大学的 Gene Spafford 提醒我说操作系统“应该提供便利的抽象”。我之前一个名为 Phil Enslow 的教授曾经定义操作系统是有秩序，有规则，有策略的控制计算机共享资源的系统。这是一个很好的观点，这是一个很好的观点，因为它包含有安全策略和调度策略还有其他类似的，这些通常不被认作是人机接口的一部分，或者是应用程序运行环境的一部分。操作系统提高硬件的利用率，为用户提供便利。它可以类比为一个自身不提供什么功能的政府，但是提供环境给其他有具体功能的应用程序。

操作系统是系统资源的分配器。同时它也控制应用程序，阻止对计算机和输入输出设备的不当操作。

最初 (可追溯到 1954 年) 计算机只有硬件。(Wilkes 的学生 Stan Kelly-Bootle 告诉我，“我偏向于认为大约在 1953 年或 1954 年 Swinnerton-Dwyer 研制的 EDSAC 监视器是第一个真正的操作系统”)。早期的计算机 Massive 足有房间大小，程序员通过在一个控制台上输入程序，然后手动将程序加载到内存：首先通过前面板上的开关逐条输入指令，然后将这些指令打孔在卡片或者纸带上。程序员通过观察控制台上灯泡的点亮状态查看程序的执行情况，发现错误，或者检查内存或者寄存器的内容。运行结果或者直接打印出来，或者打孔在卡片纸带上。

越来越多的计算机硬件被制造出来，读卡器，线性打印机，磁带设备。还有越来越多通用功能库被开发出来 (通用功能库无需修改就可以复制到新的应用中。起初程序打孔在纸带上，按照顺序依次输入机器)。随着硬件软件越来越多的出现，问题也随着而来。

每一个输入输出设备都有独自的特性。每个设备都有独特的缓冲，标志，寄存器，特殊位，都需要为其编写名为设备驱动的特殊子程序。

然后就有了编译器。编译器将高级编程语言翻译成机器语言。1952 年 Grace Hopper 和他的团队在雷明顿设计了第一个编译器。之后 FORTRAN，COBOL 等各种语言的编译器都被开发出来。这些编译器让程序员的工作变得轻松起来，但是却让软件变得更加复杂。

FORTRAAN 提供了一个很哈奥的例子。为了运行一个 FORTRAN 应用，操作员必须将 FORTRAN 编译器加载到计算机。这需要将相应的纸带放到纸带驱动器上。应用 (在卡片上穿孔的) 被放入一个读卡器并且输入到啊另一个纸带上。FORTRAN 编译器输出的汇编语言代码需要汇编，这就需要另外的汇编器纸带。汇编器将程序和必要的库链接起来，最后输出的二进制代码就会被执行。它将在控制台上加载和调试，通常并不这样做。

在做上面所有这些工作的时候，CPU 是在一旁闲置的。当挂载纸带的时候，CPU 是空闲的。为了增加利用率，任务被划分为一组一组的批量工作：这些是 FORTRAN，那些事 COBOL 等等。但仍旧还是有很多问题。

这样浪费浪费掉的计算机时间实在是太昂贵了。

第一个解决方法是离线处理，在挂载到计算机前把任务批量打在纸带上。这样在不同的机器上执行，CPU 和 IO 操作就可以同时进行了。但是为什么不把这些工作在一台机器上同时进行呢？这样就是缓冲 (为不同速度的设备临时存储数据) 和假脱机 (在主进程上分离慢的设备)。假脱机使得 CPU 和 IO 操作都能以很快的速度进行。同时它也带来了任务池的可能性，这将带来任务调度的登场。

任务调度带来的最大好处是能够实现多重运程。多重运程实现了我们现在使用计算机的方式，即等待一个应用完成的时候，执行另外一个应用：等待水烧开的同时，做了面包。在 50 年代后期，这称之为中断。外围设备在中央处理器 (CPU) 的调度下开始一个任务，然后独立自动工作。当任务完成或者设备需要获得系统资源，设备发送一个中断给 CPU，强制把系统调度的焦点放回到设备上。

Doug McIlroy 向我指出一个“有趣的退步”。当 IBM 704 运送到 MIT 的时候，已将在旋风上实现的自动操作却没有了。

多重运程的实现逻辑是多任务和分时。让我们到 MIT 去看看这个。
